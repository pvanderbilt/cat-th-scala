package category
import category._

/*
 * Natural Transformation: A mapping between functors F, G: C --> D
 *    component: alpha(c: C): F(c) --> G(c)
 */

trait NatTrans { nt =>
  val DomC: Category; // C
  val CodC: Category; // D
  val DomF: Functor;  // F  // { override val DomC = this.DomC; val CodC = this.CodC }; 
  val CodF: Functor;  // G  // { val DomC = this.DomC; val CodC = this.CodC };
  def component: DomC.TObj => CodC.TArr;
  // def checkCommutes (arr: nt.DomC.TArr): Boolean =
  //   ( CodC.comp( CodF.arrMap(arr), component(DomC.dom(arr)) )
  //     == CodC.comp( component(DomC.cod(arr)), DomF.arrMap(arr) ) )
}

  // Error generated by checkCommutes above
  // [error]  found   : arr.type (with underlying type NatTrans.this.DomC.TArr)
  // [error]  required: NatTrans.this.CodF.DomC.TArr
  // [error]     ( CodC.comp( CodF.arrMap(arr), component(DomC.dom(arr)) )
  // [error]                              ^
  // [error]  found   : arr.type (with underlying type NatTrans.this.DomC.TArr)
  // [error]  required: NatTrans.this.DomF.DomC.TArr
  // [error]       == CodC.comp( component(DomC.cod(arr)), DomF.arrMap(arr) ) )
  // [error]                                                           ^

trait NatTrans2 { nt =>
  val DomC: Category; // C
  val CodC: Category; // D
  val DomF: Functor {
    val DomC: Category { type TObj = nt.DomC.TObj; type TArr = nt.DomC.TArr };
    val CodC: Category { type TObj = nt.CodC.TObj; type TArr = nt.CodC.TArr }
  };
  val CodF: Functor {
    val DomC: Category { type TObj = nt.DomC.TObj; type TArr = nt.DomC.TArr };
    val CodC: Category { type TObj = nt.CodC.TObj; type TArr = nt.CodC.TArr }
  };
  def component: DomC.TObj => CodC.TArr;

  // naturality condition
  def checkCommutes (arr: nt.DomC.TArr): Boolean =
    ( CodC.comp( CodF.arrMap(arr), component(DomC.dom(arr)) )
      == CodC.comp( component(DomC.cod(arr)), DomF.arrMap(arr) ) )
}


object natTransOps {
  def natTransId (F: Functor): NatTrans = new NatTrans {
    val DomC: Category { type TObj = F.DomC.TObj; type TArr = F.DomC.TArr } = F.DomC;
    val CodC: Category { type TObj = F.CodC.TObj; type TArr = F.CodC.TArr } = F.CodC;
    val DomF = F;
    val CodF = F;
    def component = (x: F.DomC.TObj) => F.CodC.id(F.objMap(x));
  }

  def natTransId2 [C_TObj, C_TArr] (
    F: Functor {
      val DomC: Category { type TObj = C_TObj; type TArr = C_TArr };
      val CodC: Category { type TObj = C_TObj; type TArr = C_TArr }
    }
  ): NatTrans2 = new NatTrans2 {
    val DomC: Category { type TObj = C_TObj; type TArr = C_TArr} = F.DomC;
    val CodC: Category { type TObj = C_TObj; type TArr = C_TArr } = F.CodC;
    val DomF = F;
    val CodF = F;
    def component = (x: F.DomC.TObj) => F.CodC.id(F.objMap(x));
  }

  // def natTransCompv (
  //   beta: NatTrans2
  // )
}

object natTransExamples {

  /* 
   * δ: I --> Χ (On FinSetCat)
   */
  object delta extends NatTrans {
    type FSC = FinSetCat[FSVal];
    val DomC: Category { type TObj = FSC#TObj; type TArr = FSC#TArr } = FSCat;
    val CodC: Category { type TObj = FSC#TObj; type TArr = FSC#TArr } = FSCat;
    val DomF = functorOps.functorId(FSCat);
    val CodF = chiFun; // new ChiFun[FSVal];
    def component = (a: Set[FSVal]) => (a, (x: FSVal) => Pair(x, x), a);

    // def checkCommutes (arr: FSC#TArr): Boolean =
    //   ( FSCat.comp( CodF.arrMap(arr), component(FSCat.dom(arr)) )
    //     == FSCat.comp( component(FSCat.cod(arr)), DomF.arrMap(arr) ) )

    def checkCommutes: FSC#TArr => Boolean = { case arr@(d, f, c) => {
      val tr = FSCat.comp( chiFun.arrMap(arr), component(d))
      val lb =  FSCat.comp( component(c), arr )
      FSCat.dom(tr) == FSCat.dom(lb) && FSCat.cod(tr) == FSCat.cod(lb) &&
      d.forall( (x: FSVal) => FSCat.arrFunc(tr)(x) == FSCat.arrFunc(lb)(x) )
    } }
  }

}
